# Маршрутизация для API Gateway

# 1. Публичные endpoints авторизации (без проверки токена)
# Явно перечисляем только публичные методы
location = /api/auth/login {
    limit_req zone=auth_limit burst=5 nodelay;
    
    proxy_pass http://auth_service:8081/login;
    
    # Базовые заголовки
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    # Улучшенные настройки прокси
    proxy_connect_timeout 5s;
    proxy_read_timeout 10s;
    proxy_send_timeout 10s;
}

location = /api/auth/register {
    limit_req zone=auth_limit burst=5 nodelay;
    
    proxy_pass http://auth_service:8081/register;
    
    # Базовые заголовки
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    proxy_connect_timeout 5s;
    proxy_read_timeout 10s;
    proxy_send_timeout 10s;
}

location = /api/auth/refresh {
    limit_req zone=auth_limit burst=5 nodelay;
    
    proxy_pass http://auth_service:8081/refresh;
    
    # Базовые заголовки
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    proxy_connect_timeout 5s;
    proxy_read_timeout 10s;
    proxy_send_timeout 10s;
}

# 2. ВСЕ остальные auth endpoints требуют проверки токена
location ^~ /api/auth/ {
    limit_req zone=auth_limit burst=5 nodelay;
    
    # Проверка авторизации через внутренний запрос
    auth_request /_validate_token;
    
    # ОБРАБОТКА ОШИБОК АВТОРИЗАЦИИ
    auth_request_set $auth_status $upstream_status;
    error_page 401 = @error401;
    error_page 403 = @error403;
    
    # Извлекаем данные пользователя из ответа auth service
    auth_request_set $auth_user_id $upstream_http_x_user_id;
    auth_request_set $auth_user_roles $upstream_http_x_user_roles;
    
    # Проксируем к auth service
    proxy_pass http://auth_service:8081/;
    
    # Передаем данные пользователя в auth service
    proxy_set_header X-User-ID $auth_user_id;
    proxy_set_header X-User-Roles $auth_user_roles;
    proxy_set_header X-Auth-Validated "true";
    proxy_set_header X-Original-Authorization $http_authorization;
    
    # Auth Service получает уже проверенного пользователя
    
    # Базовые заголовки
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    proxy_connect_timeout 5s;
    proxy_read_timeout 10s;
    proxy_send_timeout 10s;
}

# 3. Защищенные endpoints поиска (с проверкой авторизации)
location ^~ /api/search/ {
    limit_req zone=search_limit burst=15 nodelay;
    
    # Проверка авторизации через внутренний запрос
    auth_request /_validate_token;
    
    # ОБРАБОТКА ОШИБОК АВТОРИЗАЦИИ
    auth_request_set $auth_status $upstream_status;
    error_page 401 = @error401;
    error_page 403 = @error403;
    
    # Извлекаем данные пользователя из ответа auth service
    auth_request_set $auth_user_id $upstream_http_x_user_id;
    auth_request_set $auth_user_roles $upstream_http_x_user_roles;
    
    # Проксируем к сервису поиска
    proxy_pass http://search_service:8082/;
    
    # Передаем данные пользователя в search service
    proxy_set_header X-User-ID $auth_user_id;
    proxy_set_header X-User-Roles $auth_user_roles;
    proxy_set_header X-Auth-Validated "true";
    proxy_set_header X-Original-Authorization $http_authorization;
    
    # Search Service получает уже проверенного пользователя
    
    # Базовые заголовки
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    proxy_connect_timeout 5s;
    proxy_read_timeout 10s;
    proxy_send_timeout 10s;
}

# 4. Внутренний endpoint для проверки токена
location = /_validate_token {
    internal;
    
    proxy_method POST;
    proxy_pass http://auth_service:8081/api/v1/validate;
    
    # Не передаем тело оригинального запроса
    proxy_pass_request_body off;
    
    # Устанавливаем заголовки
    proxy_set_header Content-Type "application/json";
    proxy_set_header Content-Length "";
    
    # Формируем тело запроса с токеном
    proxy_set_body '{"token": "$http_authorization"}';
    
    # Таймауты для защиты от зависаний
    proxy_connect_timeout 3s;
    proxy_read_timeout 10s;
    proxy_send_timeout 10s;
    
    # Кэширование результатов проверки (опционально)
    # proxy_cache auth_cache;
    # proxy_cache_key "$http_authorization";
    # proxy_cache_valid 200 60s;
    # proxy_cache_valid 401 5s;
}

# 5. Обработчики ошибок авторизации
location @error401 {
    add_header Content-Type application/json;
    return 401 '{"error": "Unauthorized", "message": "Invalid or expired token", "code": "INVALID_TOKEN"}';
}

location @error403 {
    add_header Content-Type application/json;
    return 403 '{"error": "Forbidden", "message": "Insufficient permissions", "code": "INSUFFICIENT_PERMISSIONS"}';
}

# 6. Catch-all для несуществующих путей (опционально)
location /api/ {
    add_header Content-Type application/json;
    return 404 '{"error": "Not Found", "message": "API endpoint does not exist", "code": "ENDPOINT_NOT_FOUND"}';
}